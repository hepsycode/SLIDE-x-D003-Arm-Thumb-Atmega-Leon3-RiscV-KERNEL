        -:    0:Source:/home/federico/Scrivania/SLIDE-x-Repository/SLIDE-x/SLIDE-x-BENCH/KERNEL/mergesort/frst.c
        -:    0:Graph:frst.gcno
        -:    0:Data:frst.gcda
        -:    0:Runs:1
        -:    1:#include <stdint.h>
        -:    2:#include <values.h>
        -:    3:
        -:    4:typedef uint8_t TARGET_INDEX;
        -:    5:typedef double TARGET_TYPE;
        -:    6:
function merge called 3 returned 100% blocks executed 95%
        3:    7:void merge(TARGET_INDEX left, TARGET_INDEX right, TARGET_INDEX middle)
        -:    8:{
        -:    9:	// Indexes
        3:   10:	TARGET_INDEX i, j, k = 0;
        3:   11:	TARGET_INDEX i1 = middle - left + 1;
        3:   12:	TARGET_INDEX i2 = right - middle;
        -:   13:
        -:   14:	// Temporary Arrays
        3:   15:	TARGET_TYPE x[size], y[size] = {0};
        -:   16:
        -:   17:	// Copy elements in the temporary arrays x, y
        7:   18:	for(i = 0; i < i1; i++)
unconditional  0 taken 3
branch  1 taken 4
branch  2 taken 3 (fallthrough)
        4:   19:		x[i] = a[left + i];
unconditional  0 taken 4
        -:   20:
        7:   21:	for(i = 0; i < i2; i++)
unconditional  0 taken 3
branch  1 taken 4
branch  2 taken 3 (fallthrough)
        4:   22:		y[i] = a[middle + 1 + i];
unconditional  0 taken 4
        -:   23:	
        3:   24:	i = 0;
        3:   25:	j = 0;
        3:   26:	k = left;
        8:   27:	while(i < i1 && j < i2)
unconditional  0 taken 3
branch  1 taken 8 (fallthrough)
branch  2 taken 0
branch  3 taken 5
branch  4 taken 3 (fallthrough)
        -:   28:	{		
        5:   29:		if(x[i] <= y[j])
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        1:   30:			a[k] = x[i++];
unconditional  0 taken 1
        -:   31:		else
        4:   32:			a[k] = y[j++];
unconditional  0 taken 4
        -:   33:
        5:   34:		k += 1;
unconditional  0 taken 5
        -:   35:	}
        -:   36:	
        6:   37:	while(i < i1)
unconditional  0 taken 3
branch  1 taken 3
branch  2 taken 3 (fallthrough)
        -:   38:	{
        3:   39:		a[k] = x[i];
        3:   40:		i++;
        3:   41:		k++;
unconditional  0 taken 3
        -:   42:	}
        -:   43:	
        3:   44:	while(j < i2)
unconditional  0 taken 3
branch  1 taken 0
branch  2 taken 3 (fallthrough)
        -:   45:	{
    #####:   46:		a[k] = y[j];
    #####:   47:		j++;
    #####:   48:		k++;
unconditional  0 never executed
        -:   49:	}
        3:   50:}
        -:   51:
function mergesort_0 called 7 returned 100% blocks executed 100%
        7:   52:void mergesort_0(TARGET_INDEX left, TARGET_INDEX right)
        -:   53:{
        7:   54:	if(left < right)
branch  0 taken 3 (fallthrough)
branch  1 taken 4
        -:   55:	{
        3:   56:		TARGET_INDEX middle = left+(right-left)/2;
        -:   57:
        3:   58:		mergesort_0(left, middle);
call    0 returned 3
        3:   59:		mergesort_0(middle+1, right);
call    0 returned 3
        -:   60:
        3:   61:		merge(left, right, middle);
call    0 returned 3
unconditional  1 taken 3
        -:   62:	}
        7:   63:}
        -:   64:
function mergesort called 1 returned 100% blocks executed 100%
        1:   65:void mergesort()
        -:   66:{
        1:   67:	mergesort_0(0, size-1);
call    0 returned 1
        1:   68:}
        -:   69:
function main called 1 returned 100% blocks executed 100%
        1:   70:void main()
        -:   71:{
        1:   72:	mergesort();
call    0 returned 1
        1:   73:}
